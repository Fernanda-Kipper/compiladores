PARSER_BEGIN(KarloffParser)
import java.io.*;
import java.util.ArrayList;


class Main{

  ArrayList<Command> commands;
  ArrayList<VarDecl> vars;

  Main(ArrayList<Command> commands, ArrayList<VarDecl> vars){
    this.commands = commands;
    this.vars = vars;
  }
}

class VarDecl {
  String typo;
  Token id;

  VarDecl(String typo, Token id){
    this.typo = typo;
    this.id = id;
  }
}

class Command {}

class Atrib extends Command {
  Token id;
  Exp exp;

  Atrib(Token id, Exp exp){
    this.id = id;
    this.exp = exp;
  }

  public String toString() {
    return this.id + " = " + this.exp.toString() + ";\n";
  }
}

class PrintStatement extends Command {
  Exp exp;

  PrintStatement(Exp exp){
    this.exp = exp;
  }
}

class IfStatement extends Command {
  Exp exp;
  ArrayList<Command> commands;

  IfStatement(Exp exp, ArrayList<Command> commands){
    this.exp = exp;
    this.commands = commands;
  }
}

class WhileStatement extends Command {
  Exp exp;
  ArrayList<Command> commands;

  WhileStatement(Exp exp, ArrayList<Command> commands){
    this.exp = exp;
    this.commands = commands;
  }
}

//TODO: PERGUNTAR SE Ã‰ ASSIM
class RepeatStatement extends Command {
  Exp exp;
  ArrayList<Command> commands;

  RepeatStatement(Exp exp, ArrayList<Command> commands){
    this.exp = exp;
    this.commands = commands;
  }
}

class ReturnStatement extends Command {
  Exp exp;

  ReturnStatement(Exp exp){
    this.exp = exp;
  }
}

class Exp {}

class BooleanExp extends Exp {
  boolean value;

  BooleanExp(boolean value){
    this.value = value;
  }
}

class IntExp extends Exp {
  int value;

  IntExp(int value){
    this.value = value;
  }
}

class Operator {}

class Sum extends Operator {
  String op = "+";

  public String toString() {
    return this.op;
  }
}

class Sub extends Operator {
  String op = "-";

  public String toString() {
    return this.op;
  }
}

class Mult extends Operator {
  String op = "*";

  public String toString() {
    return this.op;
  }
}

class Div extends Operator {
  String op = "/";

  public String toString() {
    return this.op;
  }
}

class And extends Operator {
  String op = "&&";

  public String toString() {
    return this.op;
  }
}

class Or extends Operator {
  String op = "||";

  public String toString() {
    return this.op;
  }
}

class Bigger extends Operator {
  String op = ">";

  public String toString() {
    return this.op;
  }
}

class Smaller extends Operator {
  String op = "<";

  public String toString() {
    return this.op;
  }
}

class Compare extends Operator {
  String op = "==";

  public String toString() {
    return this.op;
  }
}


class KarloffTree {

  Main main;
  ArrayList<Func> functions;

  KarloffTree(Main main, ArrayList<Func> functions){
    this.main = main;
    this.functions = functions;
  }

  public String toString() {
    String body = "";
    body = body.concat(this.main.toString() + "\n");
    
    for (Funcao funcao : this.funcoes) {
      body = body.concat(funcao.toString() + "\n");
    }

    body = body + "main();\n";
    
    return body;
  }
}

public class KarloffParser {

  public static void main(String args[]) throws ParseException, IOException {
    KarloffParser parser = new KarloffParser(new FileInputStream(args[0]));
    KarloffTree tree = parser.Karloff();
  }

}

PARSER_END(KarloffParser)

SKIP:
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN:
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <APAR: "(">
| <FPAR: ")">
| <BOOL: "bool">
| <INT: "integer">
| <VOID: "void">
| <FUNC: "func">
| <PLUS: "+">
| <MINUS: "-">
| <EQUALS: "==">
| <ATRIB: "=">
| <MINOR: "<">
| <MINOR_EQ: "<=">
| <MAJOR: ">">
| <MAJOR_EQ: ">=">
| <AND: "&">
| <OR: "|">
| <MUL: "*">
| <DIV: "/">
| <COMM: ",">
| <DOTCOMM: ";">
| <SYSOUT: "System.output">
| <SYSREAD: "System.readint">
| <RETURN: "return">
| <REPEAT: "repeat">
| <UNTIL: "until">
| <WHILE: "while">
| <IF: "if">
| <VAR: "newVar">
| <TRUE: "true">
| <FALSE: "false">
}

TOKEN:
{
  <NUM: (["0"-"9"])+>
  | <ID: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9", "_"])*>
}

void Karloff():
{
  Main main = null;  
  ArrayList<Func> func = new ArrayList<Func>();
}
{
  main = MainFunc()
  (Func(func))*

  {return new KarloffTree(main,func);}
}

void MainFunc():
{
  ArrayList<VarDecl> vars = new ArrayList<VarDecl>(); 
  ArrayList<Command> commands = new ArrayList<Command>();
}
{
  Type() <MAIN> <APAR> <FPAR> <ACHAVES>
  VarDecl(vars)
  (c=Statement() {commands.add(c);})*
  <FCHAVES>

  {return new Main(vars,commands);}
}

void Func():
{}
{
  <FUNC> Type() <ID> <APAR> (ArgList())? <FPAR> <ACHAVES>
  VarDecl()
  (Statement())*
  <FCHAVES>
}

void ArgList():
{}
{
  Type() <ID> (ArgListRecursion())*
}

void ArgListRecursion():
{}
{
  <COMM> Type() <ID> ArgListRecursion()
}

void VarDecl(ArrayList<VarDecl> vars):
{
  Token id=null;
  String typo=null;
}
{
  (<VAR> typo=Type() id=<ID> <DOTCOMM>{vars.add(new VarDecl(typo,id.image));})*
}

String Type():
{Token tipo = null;}
{
  tipo=<INT> | tipo=<BOOL> | tipo=<VOID>

  {return tipo.image;}
}

void Statement(ArrayList<Command> commands):
{}
{
  (Assignment(commands) | PrintStatement(commands) | IfStatement(commands) | WhileStatement(commands) | RepeatStatement(commands) | ReturnStatement(commands))
  <DOTCOMM>
}

void Assignment(ArrayList<Command> commands):
{}
{
  id=<ID> <ATRIB> e=Expression() {commands.add(new Atrib(id,e));} 
}

void PrintStatement(ArrayList<Command> commands):
{}
{
  <SYSOUT> <APAR> e=Expression() {commands.add(new PrintStatement(e));} <FPAR>
}

void IfStatement(ArrayList<Command> commands):
{
  ArrayList<Command> insideCommands = new ArrayList<Command>();
}
{
  <IF> <APAR> e=Expression() <FPAR> <ACHAVES>
  (Statement(insideCommands))+
  <FCHAVES>
  {commands.add(new IfStatement(e, insideCommands));}
}

void WhileStatement(ArrayList<Command> commands):
{
  ArrayList<Command> insideCommands = new ArrayList<Command>();
}
{
  <WHILE> <APAR> e=Expression() <FPAR> <ACHAVES>
  (Statement(insideCommands))+
  <FCHAVES>
  {commands.add(new WhileStatement(e, insideCommands));}
}

void RepeatStatement():
{
    ArrayList<Command> insideCommands = new ArrayList<Command>();
}
{
  <REPEAT> <ACHAVES>
  (Statement(insideCommands))+
  <FCHAVES> <UNTIL> <APAR> e=Expression() <FPAR>
  {commands.add(new RepeatStatement(e, insideCommands));}
}

void ReturnStatement():
{}
{
  <RETURN> Expression()
}

void RelExpr():
{}
{
  AddExpr() (
    <EQUALS> AddExpr()
    | <MINOR> AddExpr()
    | <MINOR_EQ> AddExpr()
    | <MAJOR> AddExpr()
    | <MAJOR_EQ> AddExpr()
  )?
}

void AddExpr():
{}
{
  MulExpr() (<PLUS> MulExpr())*
}

void MulExpr():
{}
{
  UnaryExpr() (<MUL> UnaryExpr())*
}

void UnaryExpr():
{}
{
  (<PLUS> | <MINUS>) UnaryExpr() | PrimaryExpr()
}

void Expression():
{}
{
  OrExpr()
}

void OrExpr():
{}
{
  AndExpr() (<OR> AndExpr())*
}

void AndExpr():
{}
{
  RelExpr() (<AND> RelExpr())*
}

void PrimaryExpr():
{}
{
  <NUM> | <ID> | <TRUE> | <FALSE> | <APAR> Expression() <FPAR>
}