PARSER_BEGIN(KarloffParser)
import java.io.*;
import java.util.ArrayList;


class Main{

  ArrayList<Command> commands;
  ArrayList<VarDecl> vars;

  Main(ArrayList<Command> commands, ArrayList<VarDecl> vars){
    this.commands = commands;
    this.vars = vars;
  }
}

class FunctionDecl{
  ArrayList<Command> commands;
  ArrayList<VarDecl> vars;
  ArrayList<Parameter> parameters;

  FunctionDecl(ArrayList<Command> commands, ArrayList<VarDecl> vars, ArrayList<Parameter> parameters){
    this.commands = commands;
    this.vars = vars;
    this.parameters = parameters;
  }
}

class VarDecl {
  String typo;
  String id;

  VarDecl(String typo, String id){
    this.typo = typo;
    this.id = id;
  }
}

class Parameter {
  String typo;
  String id;

  Parameter(String typo, String id){
    this.typo = typo;
    this.id = id;
  }
}

class Command {}

class Atrib extends Command {
  Token id;
  Exp exp;

  Atrib(Token id, Exp exp){
    this.id = id;
    this.exp = exp;
  }

  public String toString() {
    return this.id + " = " + this.exp.toString() + ";\n";
  }
}

class PrintStatement extends Command {
  Exp exp;

  PrintStatement(Exp exp){
    this.exp = exp;
  }
}

class IfStatement extends Command {
  Exp exp;
  ArrayList<Command> commands;

  IfStatement(Exp exp, ArrayList<Command> commands){
    this.exp = exp;
    this.commands = commands;
  }
}

class WhileStatement extends Command {
  Exp exp;
  ArrayList<Command> commands;

  WhileStatement(Exp exp, ArrayList<Command> commands){
    this.exp = exp;
    this.commands = commands;
  }
}


class RepeatStatement extends Command {
  Exp exp;
  ArrayList<Command> commands;

  RepeatStatement(Exp exp, ArrayList<Command> commands){
    this.exp = exp;
    this.commands = commands;
  }
}

class ReturnStatement extends Command {
  Exp exp;

  ReturnStatement(Exp exp){
    this.exp = exp;
  }
}

class Factor {}

class BooleanFactor extends Factor {
  String value;

  BooleanFactor(String value){
    this.value = value;
  }

  public String toString() {
    return this.value;
  }
}

class IntFactor extends Factor {
  String value;

  IntFactor(String value){
    this.value = value;
  }

  public String toString() {
    return this.value;
  }
}

class Operator {}

class Sum extends Operator {
  String op = "+";

  public String toString() {
    return this.op;
  }
}

class Sub extends Operator {
  String op = "-";

  public String toString() {
    return this.op;
  }
}

class Mult extends Operator {
  String op = "*";

  public String toString() {
    return this.op;
  }
}

class Div extends Operator {
  String op = "/";

  public String toString() {
    return this.op;
  }
}

class And extends Operator {
  String op = "&&";

  public String toString() {
    return this.op;
  }
}

class Or extends Operator {
  String op = "||";

  public String toString() {
    return this.op;
  }
}

class Bigger extends Operator {
  String op = ">";

  public String toString() {
    return this.op;
  }
}

class Smaller extends Operator {
  String op = "<";

  public String toString() {
    return this.op;
  }
}

class Compare extends Operator {
  String op = "==";

  public String toString() {
    return this.op;
  }
}

class Expression {}

class Operation extends Expression {
  Operator operator;
  Expression left, right;

  Operation(Operator operator, Expression left, Expression right){
    this.operator = operator;
    this.left = left;
    this.right = right;
  }

  public String toString() {
    return this.left.toString() + " " + this.operator.toString() + " " + this.right.toString(); 
  }
}


class KarloffTree {

  Main main;
  ArrayList<FunctionDecl> functions;

  KarloffTree(Main main, ArrayList<FunctionDecl> functions){
    this.main = main;
    this.functions = functions;
  }

  public String toString() {
    String body = "";
    body = body.concat(this.main.toString() + "\n");
    
    for (Funcao funcao : this.funcoes) {
      body = body.concat(funcao.toString() + "\n");
    }

    body = body + "main();\n";
    
    return body;
  }
}

public class KarloffParser {

  public static void main(String args[]) throws ParseException, IOException {
    KarloffParser parser = new KarloffParser(new FileInputStream(args[0]));
    KarloffTree tree = parser.Karloff();
  }

}

PARSER_END(KarloffParser)

SKIP:
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN:
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <APAR: "(">
| <FPAR: ")">
| <BOOL: "bool">
| <INT: "integer">
| <VOID: "void">
| <FUNC: "func">
| <PLUS: "+">
| <MINUS: "-">
| <EQUALS: "==">
| <ATRIB: "=">
| <MINOR: "<">
| <MINOR_EQ: "<=">
| <MAJOR: ">">
| <MAJOR_EQ: ">=">
| <AND: "&">
| <OR: "|">
| <MUL: "*">
| <DIV: "/">
| <COMM: ",">
| <DOTCOMM: ";">
| <SYSOUT: "System.output">
| <SYSREAD: "System.readint">
| <RETURN: "return">
| <REPEAT: "repeat">
| <UNTIL: "until">
| <WHILE: "while">
| <IF: "if">
| <VAR: "newVar">
| <TRUE: "true">
| <FALSE: "false">
}

TOKEN:
{
  <NUM: (["0"-"9"])+>
  | <ID: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9", "_"])*>
}

void Karloff():
{
  Main main = null;  
  ArrayList<FunctionDecl> functions = new ArrayList<FunctionDecl>();
}
{
  main = MainFunc()
  (Func(functions))*

  {return new KarloffTree(main,functions);}
}

void MainFunc():
{
  ArrayList<VarDecl> vars = new ArrayList<VarDecl>(); 
  ArrayList<Command> commands = new ArrayList<Command>();
}
{
  Type() <MAIN> <APAR> <FPAR> <ACHAVES>
  VarDecl(vars)
  (c=Statement() {commands.add(c);})*
  <FCHAVES>

  {return new Main(vars,commands);}
}

void Func(ArrayList<FunctionDecl> functions):
{
  ArrayList<VarDecl> vars = new ArrayList<VarDecl>(); 
  ArrayList<Command> commands = new ArrayList<Command>();
  ArrayList<Parameter> parameters = new ArrayList<Parameter>();
}
{
  <FUNC> Type() <ID> <APAR> (ArgList(parameters))? <FPAR> <ACHAVES>
  VarDecl(vars)
  (c=Statement() {commands.add(c);})*
  <FCHAVES>
  {functions.add(new FunctionDecl(commands,vars,parameters));}
}

void ArgList(ArrayList<Parameter> parameters):
{}
{
  t=Type() id=<ID> {parameters.add(new Parameter(t, id.image));} (ArgListRecursion(parameters))*
}

void ArgListRecursion(ArrayList<Parameter> parameters):
{}
{
  <COMM> t=Type() id=<ID> {parameters.add(new Parameter(t, id.image));} ArgListRecursion(parameters)
}

void VarDecl(ArrayList<VarDecl> vars):
{
  Token id=null;
  String typo=null;
}
{
  (<VAR> typo=Type() id=<ID> <DOTCOMM>{vars.add(new VarDecl(typo,id.image));})*
}

String Type():
{
  Token typo = null;
}
{
  typo=<INT> | typo=<BOOL> | typo=<VOID>

  {return typo.image;}
}

void Statement(ArrayList<Command> commands):
{}
{
  (Assignment(commands) | PrintStatement(commands) | IfStatement(commands) | WhileStatement(commands) | RepeatStatement(commands) | ReturnStatement(commands))
  <DOTCOMM>
}

void Assignment(ArrayList<Command> commands):
{}
{
  id=<ID> <ATRIB> e=Expression() {commands.add(new Atrib(id,e));} 
}

void PrintStatement(ArrayList<Command> commands):
{}
{
  <SYSOUT> <APAR> e=Expression() {commands.add(new PrintStatement(e));} <FPAR>
}

void IfStatement(ArrayList<Command> commands):
{
  ArrayList<Command> insideCommands = new ArrayList<Command>();
}
{
  <IF> <APAR> e=Expression() <FPAR> <ACHAVES>
  (Statement(insideCommands))+
  <FCHAVES>
  {commands.add(new IfStatement(e, insideCommands));}
}

void WhileStatement(ArrayList<Command> commands):
{
  ArrayList<Command> insideCommands = new ArrayList<Command>();
}
{
  <WHILE> <APAR> e=Expression() <FPAR> <ACHAVES>
  (Statement(insideCommands))+
  <FCHAVES>
  {commands.add(new WhileStatement(e, insideCommands));}
}

void RepeatStatement(ArrayList<Command> commands):
{
  ArrayList<Command> insideCommands = new ArrayList<Command>();
}
{
  <REPEAT> <ACHAVES>
  (Statement(insideCommands))+
  <FCHAVES> <UNTIL> <APAR> e=Expression() <FPAR>
  {commands.add(new RepeatStatement(e, insideCommands));}
}

void ReturnStatement(ArrayList<Command> commands):
{}
{
  <RETURN> e=Expression()
  {commands.add(new ReturnStatement(e));}
}

void Expression():
{}
{
  left=PrimaryExpr() op=Op() right=PrimaryExpr() {return new Operation(op, left, right);}
| <APAR> e=Expression() {return e;} <FPAR>
| factor=PrimaryExpr() {return factor;}
}

void PrimaryExpr():
{}
{
  num=<NUM> {return new IntFactor(num.image);} 
| <TRUE> {return new BooleanFactor("true");} 
| <FALSE> {return new BooleanFactor("false");}
}

void Op() :
{}
{
  <PLUS> {return new Sum();}
|   <MINUS> {return new Sub();}
|   <MUL> {return new Mult();}
|   <DIV> {return new Div();}
|   <AND> {return new And();}
|   <OR> {return new Or();}
|   <MAJOR> {return new Bigger();}
|   <MINOR> {return new Smaller();}
|   <EQUALS> {return new Compare();}
}